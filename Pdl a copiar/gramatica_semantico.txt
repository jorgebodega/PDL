// DicTS[ident] := (TS,Desp) // asi se usa el Diccionario de TS
// TS_actual => nombre TS actual
// Desp_actual => desplazamiento TS actual
// ptr_actual => identificador (ident) TS actual en DicTS
// buscarTS => busca si existe TS en DicTS
// buscarId => busca si exixte el id en la TS actual, en caso contrario devuelve null
// buscarTipoId => busca si existe el id en la TS actual y devuelve su tipo, si no existe devuelve null
// buscarTipoFuncion => busca si existe el id en la TS actual y es de tipo "function" y devuelve el tipo de parametros que se le pasa, si no existe, o no es funcion, devuelve null
// insertarTS => inserta un id en la TS actual
// insertarFunTs => inserta los parametros de una funcion dado un ptr_TS valido
// crearTS => crea una TS nueva

P' â†’ 
	{{ 
	ptrTS_actual = "TS_General"
	DicTS[ptrTS_actual] = [ [], 0, "null"] // (TS,Desp,TS_padre)
	}} 
	P 
	{{ 
	TS_actual = "null"
	}}

P â†’ B Z P ( No hace nada)
P â†’ F Z P ( No hace nada)
P â†’ Z P ( No hace nada)
P â†’ eof ( No hace nada)

Z â†’ cr  ( No hace nada)

F â†’ function H id 
	{{
	if buscarTS(id.ent) â‰  null
		Then Error (â€œFunciÃ³n ya declaradaâ€)
	else
		insertarTS(id.ent, "function", Desp_actual, ptrTS_actual)
		DicTS[ptrTS_actual] := (TS_actual,Desp_actual) // guarda la TS actual con el desplazamiento
		crearTS TS_nueva
		TS_actual := TS_nueva
		Desp_actual := 0
		ptrTS_anterior := ptrTS_actual
		ptrTS_actual := id.ent
	}}
	(A) Z {
	{{
	insertarFunTS(ptrTS_anterio, id.ent, A.numParam, A.tipo, id.ent)   
	}}
	Z C }
	{{
	if C.tipo â‰  H.tipo or C.tipo â‰  tipo_ok
		Then Error (â€œFuncion mal returnâ€)
	else
		Then
		DicTS[ptrTS_actual] := (TS_actual,Desp_actual) // guarda la TS actual con el desplazamiento
		DicTS[ptrTS_anterior] := (TS_anterior,Desp_anterior) // recuperamos la tabla de simbolos anterior
		TS_actual 	:= TS_anterior
		Desp_actual := Desp_anterior
		ptrTS_actual  := ptrTS_anterio
		ptrTS_anterio := null
	}}

H â†’ T 		{{ H.tipo = T.tipo , H.tamano = T.tamano }}
H â†’ ğº       {{ H.tipo = tipo_vacio  , H.tamano = 0 }}

T â†’ int 	{{ T.tipo = entero , T.tamano = 2 }}
T â†’ bool 	{{ T.tipo = logico , T.tamano = 1 }}
T â†’ chars 	{{ T.tipo = cadena  , T.tamano = 2 }}

A â†’ T id 
	{{
	if buscarId(id.ent) â‰  null
		Then Error (â€œIdentificador ya creadoâ€)
	else
		Then 
			insertarTS(id.ent, T.tipo, Desp_actual, ptrTS_actual)
		 	Desp_actual += T.tamano 
	}} 

	K 

	{{ 
	A.tipo := f(T.tipo, K.tipo) 
	A.numParam := K.numParam + 1
	}}

A â†’ ğº 
	{{ 
	A.tipo = tipo_vacio
	A.numParam := 0
	}}

K0 â†’ , T id 
	{{
	if buscarId(id.ent) â‰  null
		Then Error (â€œIdentificador ya creadoâ€)
	else
		Then 
			insertarTS(id.ent, T.tipo, Desp_actual, ptrTS_actual)
		 	Desp_actual += T.tamano
	}} 
	
	K1 
	
	{{ 
	K0.tipo := f(T.tipo, K1.tipo) 
	K0.numParam := K1.numParam + 1
	}}

K â†’ ğº 
	{{ 
	K.tipo = tipo_vacio
	K.numParam := 0
	}}

B â†’ var T id 
	{{
	if buscarId(id.ent) â‰  null
		Then Error (â€œIdentificador ya creadoâ€)
	else
		Then 
			insertarTS(id.ent, T.tipo, Desp_actual, ptrTS_actual)
		 	Desp_actual += T.tamano
		 	B.tipo := tipo_ok
	}} 

B â†’ if (E) 
	{{
	if E.tipo == logico
		Then B.tipo := tipo_ok
	else
		Then Error (â€œcondiciÃ³n "if" no logicaâ€)
	}}

	{ Z C } B'

	{{
	if C.tipo â‰  tipo_ok or B'.tipo â‰  tipo_ok
		Then Error (â€œcontenido "if" mal formadoâ€)
	}} 
	
B â†’ S 
	{{
	B.tipo := S.tipo
	}}

B'â†’ else { Z C } 
	{{
	if C.tipo â‰  tipo_ok 
		Then Error (â€œcontenido "else" mal formadoâ€)
	else
		Then B'.tipo := tipo_ok
	}} 

B'â†’ ğº
	{{
	B'.tipo := tipo_ok
	}}

S â†’ id S'
	{{
	if buscarTipoId(id.ent) â‰  null
		Then
			if  buscarTipoFuncion(id.ent) â‰  null // CASO: id(L)
				Then 
					if buscarTipoFuncion(id.ent) == S'.tipo 
						Then S.tipo := S'.tipo
					else
						Then Error (â€œParametros mal insertadosâ€)
			else //CASO id = E
				Then 
				if buscarTipoId(id.ent) == S'.tipo
					Then S.tipo := tipo_ok
				else
					Then Error (â€œasignacion mal formadaâ€)
	else
		Then Error (â€œIdentificador no declaradoâ€)
	}}

S â†’ return X 
	{{
	S.tipo := X.tipo
	}}

S â†’ write (E) 
	{{
	S.tipo := E.tipo
	}}

S â†’ prompt (id)
	{{
	if buscarTipoId(id.ent) â‰  "entero" or buscarTipoId(id.ent) â‰  "cadena"
		Then Error (â€œuso incorrecto de "prompt" â€)
	else
		Then S.tipo:= buscarTipoId(id.ent)
	}}

S'â†’ (L)
	{{
	S'.tipo:= L.tipo
	}}

S'â†’ = E
	{{
	S'.tipo := E.tipo
	}}

X â†’ E
	{{
	X.tipo := E.tipo
	}} 

X â†’ ğº
	{{
	X.tipo := tipo_vacio
	}}

C0 â†’ B Z C1 
	{{
	if C1.tipo â‰  tipo_error and B.tipo â‰  tipo_error
		Then  C0.tipo := tipo_ok
	else
		Then Error (â€œcontenido de corchetes mal formadoâ€)
	}}

C â†’ ğº  
	{{
	C.tipo := tipo_vacio
	}}     

L â†’ E Q 
	{{
	if E.tipo â‰  tipo_error and Q.tipo â‰  tipo_error
		Then L.tipo:= f(E.tipo,Q.tipo)
	else
		Then Error (â€œcontenido parentesis del identificador llamado mal formadoâ€)
	}}

L â†’ ğº
	{{
	L.tipo := tipo_vacio
	}}

Q0 â†’ , E Q1 
	{{
	if E.tipo â‰  tipo_error and Q1.tipo â‰  tipo_error
		Then Q0.tipo:= f(E.tipo,Q.tipo)
	else
		Then Error (â€œcontenido parentesis del identificador llamado mal formadoâ€)

	}}

Q â†’ ğº
	{{
	Q.tipo := tipo_vacio
	}}

E â†’ R E' 
	{{
	if E'.tipo â‰  tipo_vacio and R.tipo â‰  E'.tipo
		Then Error (â€œComparacion de elementos con tipos distintosâ€)
	else 
		Then
			if E'.tipo â‰  tipo_vacio
				Then E.tipo := "logico"
			else
				Then E.tipo := R.tipo 

	}}

E'0â†’ && R E'1 
	{{
	if E'1.tipo â‰  tipo_vacio and E'1.tipo â‰  R.tipo â‰  "logico"
		Then Error (â€œComparacion de elementos de tipo no logicoâ€)
	else
		Then E'0.tipo := R.tipo
	}}

E'0â†’ &= R E'1

	{{
	if E'1.tipo â‰  tipo_vacio and E'1.tipo â‰  R.tipo â‰  "logico"
		Then Error (â€œComparacion de elementos con asignacion de tipo no logicoâ€)
	else
		Then E'0.tipo := R.tipo
	}}

E'â†’ ğº
	{{
	E'.tipo := tipo_vacio
	}}

R â†’ U R'
	{{
	if R'.tipo â‰  tipo_vacio and U.tipo â‰  R'.tipo
		Then Error (â€œComparacion de elementos con tipos distintosâ€)
	else 
		Then
			if R'.tipo â‰  tipo_vacio
				Then R.tipo := "logico"
			else
				Then R.tipo := U.tipo 

	}}

R'0â†’ > U R'1
	{{
	if R'1.tipo â‰  tipo_vacio and R'1.tipo â‰  U.tipo â‰  "entero"
		Then Error (â€œComparacion de elementos de tipo no enteroâ€)
	else
		Then R'0.tipo := U.tipo
	}}

R'â†’ ğº
	{{
	R'.tipo := tipo_vacio
	}}

U â†’ V U'
	{{
	if U'.tipo â‰  tipo_vacio and V.tipo â‰  U'.tipo
		Then Error (â€œSuma de elementos de tipo no enteroâ€)
	else
		Then U.tipo := V.tipo 
	}}

U'0â†’ + V U'1 
	{{
	if V.tipo â‰  "entero"
		Then Error (â€œSuma de elementos de tipo no enteroâ€)
	else
		Then U'0.tipo := V.tipo 
	}}

U'â†’ ğº 
	{{ 
	U'.tipo := tipo_vacio
	}}

V â†’ id V' 
	{{
	if buscarTipoId(id.ent) â‰  null
		Then
			if  buscarTipoFuncion(id.ent) â‰  null // CASO: id(L)
				Then 
					if buscarTipoFuncion(id.ent) == V'.tipo 
						Then V.tipo := V'.tipo
					else
						Then Error (â€œParametros mal insertadosâ€)
			else //CASO id
				Then V.tipo := buscarTipoId(id.ent)
	else
		Then Error (â€œIdentificador no declaradoâ€)
	}}

V â†’ (E) 	{{ V.tipo := E.tipo }}
V â†’ entero 	{{ V.tipo := entero }}
V â†’ cadena 	{{ V.tipo := cadena }}
V â†’ True 	{{ V.tipo := logico }}
V â†’ False 	{{ V.tipo := logico }}

V'â†’ (L) 
	{{
	V'.tipo := L.tipo
	}}

V'â†’ ğº
	{{
	V'.tipo := tipo_vacio
	}}